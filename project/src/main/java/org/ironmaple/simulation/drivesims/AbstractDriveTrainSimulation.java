package org.ironmaple.simulation.drivesims;

import static edu.wpi.first.units.Units.Meters;

import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Translation2d;
import edu.wpi.first.math.kinematics.ChassisSpeeds;
import edu.wpi.first.math.kinematics.SwerveModuleState;
import org.ironmaple.simulation.drivesims.configs.DriveTrainSimulationConfig;
import org.ironmaple.utils.mathutils.GeometryConvertor;
import org.ironmaple.simulation.physics.PolygonShape;
import org.ironmaple.simulation.physics.Vec2;
import org.ironmaple.simulation.physics.Body;
import org.ironmaple.simulation.physics.BodyDef;
import org.ironmaple.simulation.physics.BodyType;
import org.ironmaple.simulation.physics.Fixture;
import org.ironmaple.simulation.physics.FixtureDef;
import org.ironmaple.simulation.physics.World;

/**
 *
 *
 * <h1>Represents an Abstract Drivetrain Simulation.</h1>
 *
 * <h3>Simulates the Mass, Collision Space, and Friction of the Drivetrain.</h3>
 *
 * <p>This class models the physical properties of a drivetrain, including mass and collision space.
 *
 * <p>It also provides APIs to obtain the status (position, velocity etc.) in WPILib geometry classes.
 *
 * <p>The propelling forces generated by motors are simulated in its subclass, or {@link SwerveDriveSimulation}.
 */
public abstract class AbstractDriveTrainSimulation {
    public static final double
            BUMPER_COEFFICIENT_OF_FRICTION = 0.65, // https://en.wikipedia.org/wiki/Friction#Coefficient_of_friction
            BUMPER_COEFFICIENT_OF_RESTITUTION = 0.08; // https://simple.wikipedia.org/wiki/Coefficient_of_restitution

    public final DriveTrainSimulationConfig config;

    /** The Box2D body representing this drivetrain */
    protected Body body;

    /** The main fixture for collision detection */
    protected Fixture mainFixture;

    /** Initial pose stored for body creation */
    private final Pose2d initialPose;

    /**
     *
     *
     * <h2>Creates a Simulation of a Drivetrain.</h2>
     *
     * <h3>Sets Up the Collision Space and Mass of the Chassis.</h3>
     *
     * <p>Since this is an abstract class, the constructor must be called from a subclass.
     *
     * <p>Note that the chassis does not appear on the simulation field upon creation. Refer to
     * {@link org.ironmaple.simulation.SimulatedArena} for instructions on how to add it to the simulation world.
     *
     * @param config a {@link DriveTrainSimulationConfig} instance containing the configurations of this drivetrain
     * @param initialPoseOnField the initial pose of the drivetrain in the simulation world
     */
    protected AbstractDriveTrainSimulation(DriveTrainSimulationConfig config, Pose2d initialPoseOnField) {
        this.config = config;
        this.initialPose = initialPoseOnField;
    }

    /**
     *
     *
     * <h2>Adds this drivetrain to the physics world.</h2>
     *
     * @param world the Box2D world to add to
     */
    public void addToWorld(World world) {
        BodyDef bd = new BodyDef();
        bd.type = BodyType.DYNAMIC;
        bd.position.set((float) initialPose.getX(), (float) initialPose.getY());
        bd.angle = (float) initialPose.getRotation().getRadians();
        bd.linearDamping = 0.1f;
        bd.angularDamping = 0.1f;

        this.body = world.createBody(bd);

        /* width and height in world reference is flipped */
        final float WIDTH_IN_WORLD_REFERENCE = (float) config.bumperLengthX.in(Meters);
        final float HEIGHT_IN_WORLD_REFERENCE = (float) config.bumperWidthY.in(Meters);

        PolygonShape box = new PolygonShape();
        box.setAsBox(WIDTH_IN_WORLD_REFERENCE / 2, HEIGHT_IN_WORLD_REFERENCE / 2);

        FixtureDef fd = new FixtureDef();
        fd.shape = box;
        fd.density = (float) config.getDensityKgPerSquaredMeters();
        fd.friction = (float) BUMPER_COEFFICIENT_OF_FRICTION;
        fd.restitution = (float) BUMPER_COEFFICIENT_OF_RESTITUTION;

        this.mainFixture = body.createFixture(fd);

        // Store reference to this simulation in the body's user data
        body.setUserData(this);
    }

    /**
     *
     *
     * <h2>Gets the Box2D body.</h2>
     *
     * @return the Box2D Body
     */
    public Body getBody() {
        return body;
    }

    /**
     *
     *
     * <h2>Adds a fixture to this body.</h2>
     *
     * @param fd the fixture definition
     * @return the created fixture
     */
    public Fixture addFixture(FixtureDef fd) {
        if (body != null) {
            return body.createFixture(fd);
        }
        return null;
    }

    /**
     *
     *
     * <h2>Removes a fixture from this body.</h2>
     *
     * @param fixture the fixture to remove
     */
    public void removeFixture(Fixture fixture) {
        if (body != null && fixture != null) {
            body.destroyFixture(fixture);
        }
    }

    /**
     *
     *
     * <h2>Sets the Robot's Current Pose in the Simulation World.</h2>
     *
     * <p>This method instantly teleports the robot to the specified pose in the simulation world. The robot does not
     * drive to the new pose; it is moved directly.
     *
     * @param robotPose the desired robot pose, represented as a {@link Pose2d}
     */
    public void setSimulationWorldPose(Pose2d robotPose) {
        if (body != null) {
            body.setTransform(
                    new Vec2((float) robotPose.getX(), (float) robotPose.getY()),
                    (float) robotPose.getRotation().getRadians());
            body.setLinearVelocity(new Vec2(0, 0));
            body.setAngularVelocity(0);
        }
    }

    /**
     *
     *
     * <h2>Sets the Robot's Speeds to the Given Chassis Speeds.</h2>
     *
     * <p>This method sets the robot's current velocity to the specified chassis speeds.
     *
     * <p>The robot does not accelerate smoothly to these speeds; instead, it jumps to the velocity
     * <strong>Instantaneously</strong>.
     *
     * @param givenSpeeds the desired chassis speeds, represented as a {@link ChassisSpeeds} object
     */
    public void setRobotSpeeds(ChassisSpeeds givenSpeeds) {
        if (body != null) {
            body.setLinearVelocity(GeometryConvertor.toBox2dLinearVelocity(givenSpeeds));
            body.setAngularVelocity((float) givenSpeeds.omegaRadiansPerSecond);
        }
    }

    /**
     *
     *
     * <h2>Abstract Simulation Sub-Tick Method.</h2>
     *
     * <p>This method is called every time the simulation world is updated.
     *
     * <p>It is implemented in the sub-classes of {@link AbstractDriveTrainSimulation}.
     *
     * <p>It is responsible for applying the propelling forces to the robot during each sub-tick of the simulation.
     */
    public abstract void simulationSubTick();

    /**
     *
     *
     * <h2>Gets the Actual Pose of the Drivetrain in the Simulation World.</h2>
     *
     * <p>This method is used to display the robot on <a
     * href="https://docs.advantagescope.org/tab-reference/3d-field/">AdvantageScope Field3d</a> or to <a
     * href="https://docs.photonvision.org/en/latest/docs/simulation/simulation-java.html#updating-the-simulation-world">update
     * vision simulations</a>.
     *
     * <p><strong>Note:</strong> Do not use this method to simulate odometry! For a more realistic odometry simulation,
     * use a {@link SwerveDriveSimulation} together with a
     * {@link edu.wpi.first.math.estimator.SwerveDrivePoseEstimator}.
     *
     * @return a {@link Pose2d} object yielding the current world pose of the robot in the simulation
     */
    public Pose2d getSimulatedDriveTrainPose() {
        if (body != null) {
            return GeometryConvertor.toWpilibPose2d(body.getTransform());
        }
        return initialPose;
    }

    /**
     *
     *
     * <h2>Gets the Actual Robot-Relative Chassis Speeds from the Simulation.</h2>
     *
     * <p>This method returns the actual chassis speeds of the drivetrain in the simulation, relative to the robot.
     *
     * <p>To simulate the chassis speeds calculated by encoders, use a {@link SwerveDriveSimulation} together with
     * {@link edu.wpi.first.math.kinematics.SwerveDriveKinematics#toChassisSpeeds(SwerveModuleState...)} for a more
     * realistic simulation.
     *
     * @return the actual chassis speeds in the simulation world, <strong>Robot-Relative</strong>
     */
    public ChassisSpeeds getDriveTrainSimulatedChassisSpeedsRobotRelative() {
        ChassisSpeeds speeds = getDriveTrainSimulatedChassisSpeedsFieldRelative();
        speeds = ChassisSpeeds.fromFieldRelativeSpeeds(speeds, getSimulatedDriveTrainPose().getRotation());
        return speeds;
    }

    /**
     *
     *
     * <h2>Gets the Actual Field-Relative Chassis Speeds from the Simulation.</h2>
     *
     * <p>This method returns the actual chassis speeds of the drivetrain in the simulation, relative to the robot.
     *
     * <p>To simulate the chassis speeds calculated by encoders, use a {@link SwerveDriveSimulation} together with
     * {@link edu.wpi.first.math.kinematics.SwerveDriveKinematics#toChassisSpeeds(SwerveModuleState...)} for a more
     * realistic simulation.
     *
     * @return the actual chassis speeds in the simulation world, <strong>Field-Relative</strong>
     */
    public ChassisSpeeds getDriveTrainSimulatedChassisSpeedsFieldRelative() {
        if (body != null) {
            return GeometryConvertor.toWpilibChassisSpeeds(body.getLinearVelocity(), body.getAngularVelocity());
        }
        return new ChassisSpeeds();
    }

    /**
     *
     *
     * <h2>Gets the linear velocity at a world point.</h2>
     *
     * @param worldPoint the point in world coordinates
     * @return the velocity at that point
     */
    public Vec2 getLinearVelocity(Vec2 worldPoint) {
        if (body != null) {
            return body.getLinearVelocityFromWorldPoint(worldPoint);
        }
        return new Vec2(0, 0);
    }

    /**
     *
     *
     * <h2>Gets the angular velocity.</h2>
     *
     * @return the angular velocity in radians per second
     */
    public float getAngularVelocity() {
        if (body != null) {
            return body.getAngularVelocity();
        }
        return 0;
    }

    /**
     *
     *
     * <h2>Gets the linear velocity.</h2>
     *
     * @return the linear velocity
     */
    public Vec2 getLinearVelocity() {
        if (body != null) {
            return body.getLinearVelocity();
        }
        return new Vec2(0, 0);
    }

    /**
     *
     *
     * <h2>Applies a force at the center of mass.</h2>
     *
     * @param force the force to apply
     */
    public void applyForce(Vec2 force) {
        if (body != null) {
            body.applyForceToCenter(force);
        }
    }

    /**
     *
     *
     * <h2>Applies a force at a specific point.</h2>
     *
     * @param force the force to apply
     * @param point the point to apply it at
     */
    public void applyForce(Vec2 force, Vec2 point) {
        if (body != null) {
            body.applyForce(force, point);
        }
    }

    /**
     *
     *
     * <h2>Applies a torque.</h2>
     *
     * @param torque the torque to apply
     */
    public void applyTorque(float torque) {
        if (body != null) {
            body.applyTorque(torque);
        }
    }

    /**
     *
     *
     * <h2>Sets the linear damping.</h2>
     *
     * @param damping the damping value
     */
    public void setLinearDamping(float damping) {
        if (body != null) {
            body.setLinearDamping(damping);
        }
    }

    /**
     *
     *
     * <h2>Sets the angular damping.</h2>
     *
     * @param damping the damping value
     */
    public void setAngularDamping(float damping) {
        if (body != null) {
            body.setAngularDamping(damping);
        }
    }

    /**
     *
     *
     * <h2>Sets the angular velocity.</h2>
     *
     * @param velocity the angular velocity in radians per second
     */
    public void setAngularVelocity(float velocity) {
        if (body != null) {
            body.setAngularVelocity(velocity);
        }
    }

    /**
     *
     *
     * <h2>Gets the world point from a local point.</h2>
     *
     * @param localPoint the local point
     * @return the world point
     */
    public Vec2 getWorldPoint(Vec2 localPoint) {
        if (body != null) {
            return body.getWorldPoint(localPoint);
        }
        return localPoint;
    }

    /**
     *
     *
     * <h2>Gets the mass of the body.</h2>
     *
     * @return the mass in kg
     */
    public float getMass() {
        if (body != null) {
            return body.getMass();
        }
        return 0;
    }

    /**
     *
     *
     * <h2>Gets the inertia of the body.</h2>
     *
     * @return the inertia
     */
    public float getInertia() {
        if (body != null) {
            return body.getInertia();
        }
        return 0;
    }
}
